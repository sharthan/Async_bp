<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Async.art artdemo</title>
  <script src="https://code.jquery.com/jquery-3.5.0.min.js" integrity="sha256-xNzN2a4ltkB44Mc/Jz3pT4iU1cmeR0FkXs4pru/JxaQ=" crossorigin="anonymous"></script>
  <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js" integrity="sha256-VazP97ZCwtekAsvgPBSUwPFKdrwD3unUfSGVYrahUqU=" crossorigin="anonymous"></script>
  <script language="javascript" type="text/javascript" src="script/async_token_abi.js"></script>
  <script language="javascript" type="text/javascript" src="script/async_abi.js"></script>
  <script src="https://cdn.ethers.io/lib/ethers-5.0.umd.min.js" type="application/javascript"></script>
</head>

<body>
  <!-- connect to Ethereum -->
  <button onclick="connect()">Enable Ethereum</button>
  <div class="network">
    <h2 id="nettwork"></h2>
  </div>
  <input id="inputToken" type="text" name="" value="768" onchange="inputUpdate()">
  <button onclick="owner()">Layer owner</button>
  <button onclick="getState()">Layer value</button>
  <button onclick="update()">Update</button>
  <h2 id="status"></h2>
  <h2 id="clean"></h2>

<div id="layerUpdate">
</div>

  <!-- <button  onclick="update(layerUpdater.val())">Update layer</button> -->
</body>

</html>

<script type="text/javascript">
  // Prerequisits. https://www.npmjs.com/package/http-server
  // Then run form folder dir: http-server
  var currentLeverValues = []
  //Add the token id for all the token layers here. 768 is just an example layer added by me.
  var tokenID = $("#inputToken").val()

  //Connect to the Ethereum network with MetaMask or Infura
  const provider = new ethers.providers.Web3Provider(window.ethereum)
  //   const provider = new ethers.providers.JsonRpcProvider("https://rinkeby.infura.io/v3/XXXXXXXXXXXXXXXXXXXXXXXX"


  var signer = provider.getSigner();
  var asyncAddress = "0x4F37310372dd39d451f7022EE587FA8B9F72d80B"
  const asyncContract = new ethers.Contract(asyncAddress, asyncAbi, provider);
  var ownerOfToken = []
  var controlToken
  var layer

  function inputUpdate() {
    tokenID = $("#inputToken").val()
  }

  // connects to eth network
  function connect() {
    //Will Start the metamask extension
    ethereum.request({
      method: 'eth_requestAccounts'
    });
    //Checks if the user is connected to the ETH network.
    if (ethereum.isConnected()) {
      checkNettwork()
      console.log("Is connectd to MM: " + ethereum.isMetaMask)
    } else {
      console.log("You are not connected to ETH network")
    }

  };

  const contractWithSigner = asyncContract.connect(signer)

  //Checks which network you are connected to. 1 is main net and 4 is Rinkeby
  function checkNettwork() {
    if (ethereum.networkVersion == 4) {
      //Async Contract on Rinkeby: 0x4F37310372dd39d451f7022EE587FA8B9F72d80B
      asyncAddress = "0x4F37310372dd39d451f7022EE587FA8B9F72d80B"
      $("#nettwork").text("You are connected to Rinkeby test network")
    } else if (ethereum.networkVersion == 1) {
      //Async Contract on Mainnet: 0xb6dae651468e9593e4581705a09c10a76ac1e0c8
      asyncAddress = "0xb6dae651468e9593e4581705a09c10a76ac1e0c8"
      $("#nettwork").text("You are connected to the main network")
    } else {
      asyncAddress = ""
      $("#nettwork").text("Please connect to the Mainet or the Rinkeby test nettwork")
    }
  }


var currentLeverValuesAll = []
var allMin = []
var allMax = []
var allLayerValues = []

  //Connects to the layers and get the position of all tha pieces
  async function getState() {
    controlToken = []

    controlToken = await asyncContract.getControlToken(tokenID);

    //Clear content
    currentLeverValues = []
    allMin = []
    allMax = []
    allLayerValues = []

    for (var i = 0; i < controlToken.length; i++) {
      //Creates an array with all the values form the layer
      allLayerValues.push(controlToken[i].toString())
      if (i % 3 == 2) { // every 3rd value is a current lever setting [min, max, current, min, max, current]
        //console.log(i)
        //console.log(currentLeverValues)
        currentLeverValues.push(controlToken[i].toString())
      }
      if (i % 3 == 0) { // Min values for layers
        allMin.push(controlToken[i].toString())
      }
      if (i % 3 == 1) { // max values for layers
        //console.log(i)
        //console.log(currentLeverValues)
        allMax.push(controlToken[i].toString())
      }

    }
    //Showes lever values
    $("#status").text("This is all the raw layer values [min, max, current,...]: \n " + allLayerValues)
    addChoices()
  }

  //Get the Eth address from all the token holders of layers
  async function owner() {
    ownerOfToken = await asyncContract.ownerOf(tokenID)
    //Showes wallet address of token owner.
    $("#status").text(ownerOfToken)

  }



  // This wil update the token layer. This only works if a new walue is passed to the "newValue". The same value wil fail.
  async function update() {
    //Check if logged in account own this layer.
    //To upper case because of the address might contain smaland big caps. 
    if (ownerOfToken.toUpperCase() == ethereum.selectedAddress.toUpperCase()) {
      layer = $("#inputToken").val()
      layerPosition = []
      newValue = []

      for (var i = 0; i < currentLeverValues.length; i++) {
          //If new value is not the same as the old value. update this.
          if (currentLeverValues[i] != $("#selectVal" + i).val()) {
            layerPosition.push(i)
            newValue.push($("#selectVal" + i).val())
          }
        }

    //Detect if no changes are done.
    if (newValue.length !== 0) {
      if (newValue != currentLeverValues ) {
        // Send update layer
        txChangeToken = await contractWithSigner.useControlToken(parseInt(layer), [parseInt(layerPosition)], [parseInt(newValue)])
        //Checks to see if block is mined to the BC
        txChangeToken.wait(1).then(function(value, error) {
          if (value.confirmations > 0) {
            console.log("Change made to token " + tokenID[layer])
            getState()
          } else {
            //No change made
            console.log("Error on change")
            getState()
          }
        });
        console.log(txChangeToken)

      }
    } else {
        console.log("You are trying to update the layer to itÂ´s current state, no update needed.")
    }
    } else {
      console.log("You do not own this token")
    }
}


function setToCurrent() {
 for (var i = 0; i < currentLeverValues.length; i++) {
   $("#selectVal" + i).val(currentLeverValues[i])
 }
}

// Adds new dropdowns.
function addChoices() {
  //Clear out previous content.
  $("#layerUpdate").html("")
  //Creates the slector and loades the content based on tha layer choices aviable
   for (var i = 0; i < currentLeverValues.length; i++) {
         var select = $("<select>").prop("id", "selectVal" + i )
                         //.prop("name", "Select value" + i);

         for (var j = allMin[i]; j <= allMax[i]; j++) {
           select.append($("<option>")
           .prop("value", j)
           .text(j))
         }

         var label = $("<label>").prop('for', 'pets')
                         .text("Min: " + allMin[i] + " " + "Max: " + allMax[i]+ " ");

         var br = $("<br>");

         $("#layerUpdate").append(label).append(select).append(br);
     }
     //Set the dropdown to current value
     setToCurrent()
     $("#clean").text("The raw layer values can be organized and presented like this: ")

}

  // Force page refreshes on network changes
  {
    // The "any" network will allow spontaneous network changes
    const provider = new ethers.providers.Web3Provider(window.ethereum, "any");
    provider.on("network", (newNetwork, oldNetwork) => {
      // When a Provider makes its initial connection, it emits a "network"
      // event with a null oldNetwork along with the newNetwork. So, if the
      // oldNetwork exists, it represents a changing network
      if (oldNetwork) {
        window.location.reload();
      }
    });
  }
</script>
